package io.tbd.tbdex.protocol.core;

import com.google.common.collect.ImmutableMap;
import io.tbd.tbdex.protocol.processors.AskProcessor;
import io.tbd.tbdex.protocol.processors.CloseProcessor;
import io.tbd.tbdex.protocol.processors.ConditionalOfferProcessor;
import io.tbd.tbdex.protocol.processors.MessageProcessor;

import io.tbd.tbdex.protocol.processors.OfferAcceptProcessor;
import java.util.Map;
import javax.inject.Inject;

public class MessageThreadProcessor {
    MessageThreadStore messageThreadStore;
    AskProcessor askProcessor;
    CloseProcessor closeProcessor;
    ConditionalOfferProcessor conditionalOfferProcessor;
    OfferAcceptProcessor offerAcceptProcessor;
    Map<MessageType, MessageProcessor> messageProcessors;

    @Inject
    MessageThreadProcessor(
        MessageThreadStore messageThreadStore,
        AskProcessor askProcessor,
        CloseProcessor closeProcessor,
        ConditionalOfferProcessor conditionalOfferProcessor,
        OfferAcceptProcessor offerAcceptProcessor
    ) {
        this.messageThreadStore = messageThreadStore;
        this.askProcessor = askProcessor;
        this.closeProcessor = closeProcessor;
        this.conditionalOfferProcessor = conditionalOfferProcessor;
        this.offerAcceptProcessor = offerAcceptProcessor;
        this.messageProcessors = ImmutableMap.of(
            MessageType.Ask, askProcessor,
            MessageType.Close, closeProcessor,
            MessageType.ConditionalOffer, conditionalOfferProcessor,
            MessageType.OfferAccept, offerAcceptProcessor
        );
    }

    /**
     * Adds a message to the message thread. executes any processor registered to the
     * {@link MessageType} of the message being added (if any).
     * @param message - the message being added
     * @return A resulting message generated by processing the message being added. Returns
     *         null if the message added results in no new message
     * @throws RuntimeException - if the message being added is invalid
     */
    public Message addMessage(Message message) {
        if (message == null) {
            return null;
        }

        String threadToken = message.threadID();
        Message lastMessage = messageThreadStore.getLastMessage(threadToken);

        MessageType messageType = message.type();

        if (lastMessage == null) {
            // an Ask should always be the first message
            if (messageType != MessageType.Ask) {
                throw new RuntimeException("The first message in a thread can only be an Ask");
            }
        } else {
            if (messageType == MessageType.Ask) {
                throw new RuntimeException("an Ask can only be the first message in a thread");
            }

            // TODO: Check to see if message's sender matches the sender of the last message

            if (!lastMessage.body().isValidReply(messageType)) {
                throw new RuntimeException(messageType + " is not a valid reply to the most recent message [" + lastMessage.type() + "]" + "in this thread");
            }
        }

        this.messageThreadStore.addMessageToThread(message);
        MessageProcessor processor = messageProcessors.get(message.type());

        if (processor == null) {
            return null;
        }

        Message resultingMessage = processor.process(message);
        this.addMessage(resultingMessage);

        return resultingMessage;
    }

    /**
     *
     * @param encryptedSignedJWM - the encrypted then signed message
     * @return Message
     */
    public Message addMessage(String encryptedSignedJWM) {
        // TODO: decrypt JWM using recipient's private key
        // TODO: decode JWS payload (which is the message itself)
        // TODO: get recipient's DID from the message
        // TODO: resolve the recipient's DID to get DID Doc
        // TODO: use `kid` from JWS header to grab the appropriate public key from DID Doc
        // TODO: verify the JWS

        throw new UnsupportedOperationException("Method not yet implemented");
    }
}
